
# 全体の構造

```
ソースコード　⇆ 抽象構文木(AST) ⇆ エディタ(別プロセス)
                            |
                            → 評価器 →オーディオ、MIDI出力

```
# 構文

### すべての変数宣言に対して時間の位置を付随させられる

```
input::int@ 1@100[ms] //これは絶対位置100msに置かれるinputという名前の整数1(@は時間付きであることを明示的に表す)　ブラケットで時間単位の指定　時間の単位も自分で定義可能にしたい
```

### 関数の中の任意の変数呼び出しで、過去/未来の値を参照できる、

#### 時間シフト演算子 <| と |>

```
 
delay(input::int@) = input <| 100::ms //過去の入力を出力する

future(input::int@) = input |> 100::ms //未来の入力を出力する(フィルターとか作るときに有効)

 //VSTプラグインのように全体にオフセットディレイがかかる感じ（CHronicでもやってた） 
```

### また、関数は自身の過去の出力をselfキーワードで参照できる

```
	combfilter(input) = input + 0.999*( self<|1 ) // 出力で未来の参照|>は流石にエラー
 	 }

    combfilter = input+0.999*(self <| 1[sec] ) // //絶対時間で遡ることも補完が効けばできる??無理かも
 
```


つまり、関数としてオーディオのパイプラインみたいに扱えるんだけど、内部的にはクラスのように値を保持している（配列の長さとかはコンパイル時に確定しなければエラーになる//faustと同じ）

## あんまり本質と関係ないけど実装したい機能

### Dialect機能

型/関数に対するエイリアスなんだけど、1回限りしかできない（エイリアスのエイリアスは不可）
パフォーマンスとかで短く書く用　
コンパイル時にマクロ的に変換するので実行速度に影響しない(なんでもマクロを許すと大変なことになりそうなのでこういう制約をつけたい)


### 標準的な配列に対して初めから補完機能がついてる 

```
hoge = [20,30,0.12]
```
みたいなときに

`hoge[0.3]`みたいな呼び出し方ができ、20と30の間の値が出る(補完アルゴリズムは自分で定義もできる)


## 疑問/わかってない点

オーディオドライバ周り本当にそんなにうまくいくのか

音声ファイル周りの扱い

Dialectとか配列補完とか、中間表現にするさらに手前のプリプロセッサみたいな物を用意したほうがいいのかもしれない

